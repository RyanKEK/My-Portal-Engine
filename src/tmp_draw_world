void			draw_world(t_sector *sectors, t_wall wall, t_player player, t_sdl *sdl, int *ytop, int *ybottom, int sx1, int sx2)
{
	t_vector	v1;
	t_vector	v2;
	t_vector	t1;
	t_vector	t2;
	float 		yceil;
	float 		yfloor;
	t_vector 	i1;
	t_vector 	i2;
	t_vector 	scale1; 
	t_vector 	scale2;
	int 		x1;
	int 		x2;
	int 		y1a;
	int 		y2a;
	int			begin;
	int			end;
	int 		cya;
	int 		cyb;
	int			y1b;
 	int			y2b;
	int 		ya; 
	int 		yb;

	v1 = (t_vector){wall.start.x - player.pos.x, wall.start.y - player.pos.y};
	v2 = (t_vector){wall.end.x - player.pos.x, wall.end.y - player.pos.y};

	t1.x = v1.x * player.sin_angl - v1.y * player.cos_angl;
	t1.y = v1.x * player.cos_angl + v1.y * player.sin_angl;

	t2.x = v2.x * player.sin_angl - v2.y * player.cos_angl;
	t2.y = v2.x * player.cos_angl + v2.y * player.sin_angl;
	if(t1.y <= 0 && t2.y <= 0)
		return ;

	int u0 = 0, u1 = wall.type != empty_wall? wall.texture->w - 1 : 1;

	if (t1.y <= 0 || t2.y <= 0)
	{
		float nearz = 1e-4f, farz = 5, nearside = 1e-5f, farside = 20.f;
		i1 = Intersect(t1.x,t1.y,t2.x,t2.y, -nearside,nearz, -farside,farz);
        i2 = Intersect(t1.x,t1.y,t2.x,t2.y,  nearside,nearz,  farside,farz);
		t_vector org1 = {t1.x, t1.y}, org2 = {t2.x, t2.y};
		if(t1.y < nearz)
		{
			if(i1.y > 0)
			{
				t1.x = i1.x;
				t1.y = i1.y;
			}
			else
			{
				t1.x = i2.x;
				t1.y = i2.y;
			}
		}
        if(t2.y < nearz)
		{
			if(i1.y > 0)
			{
				t2.x = i1.x;
				t2.y = i1.y;
			}
			else
			{
				t2.x = i2.x;
				t2.y = i2.y;
			}
		}
		if (wall.type != empty_wall)
		{
			if(fabs(t2.x-t1.x) > fabs(t2.y-t1.y))
    	    	    u0 = (t1.x-org1.x) * (wall.texture->w - 1) / (org2.x-org1.x), u1 = (t2.x-org1.x) * (wall.texture->w - 1) / (org2.x-org1.x);
    		    else
    		        u0 = (t1.y-org1.y) * (wall.texture->w - 1) / (org2.y-org1.y), u1 = (t2.y-org1.y) * (wall.texture->w - 1) / (org2.y-org1.y);
		}
	}

    scale1 =(t_vector) {player.hfov / t1.y, player.vfov / t1.y};
    scale2 =(t_vector) {player.hfov / t2.y, player.vfov / t2.y};
	x1 = player.half_win_size.x -(int)(t1.x * scale1.x);
	x2 = player.half_win_size.x -(int)(t2.x * scale2.x);

	if(x1 >= x2 || x2 < sx1 || x1 > sx2)
		return ;

	if (wall.type == empty_wall)
	{
		yceil = min(wall.sectors[0]->ceil, wall.sectors[1]->ceil) - player.height;
    	yfloor = max(wall.sectors[0]->floor, wall.sectors[1]->floor) - player.height;
	}
	else
	{	
		yceil = wall.sectors[0]->ceil - player.height;
    	yfloor = wall.sectors[0]->floor - player.height;
	}
	
//	y1a = player.half_win_size.y - (int)(yceil * scale1.y),  y1b = player.half_win_size.y - (int)(yfloor * scale1.y);
//  y2a = player.half_win_size.y - (int)(yceil * scale2.y),  y2b = player.half_win_size.y - (int)(yfloor * scale2.y);

	y1a = player.half_win_size.y - (int)Yaw(yceil, t1.y) * scale1.y,  y1b = player.half_win_size.y - (int)(Yaw(yfloor, t1.y) * scale1.y);
	y2a = player.half_win_size.y - (int)Yaw(yceil, t2.y) * scale2.y,  y2b = player.half_win_size.y - (int)(Yaw(yfloor, t2.y) * scale2.y);

	begin = max(x1, sx1);
	end = min(x2, sx2);

//	Scaler ya_int = Scaler_Init(x1, begin, x2, y1a, y2a);
//	Scaler yb_int = Scaler_Init(x1, begin, x2, y1b, y2b);

	for(int x = begin; x <= end && x < sdl->win_size.x; ++x)
	{
		int txtx = (u0*((x2-x)*t2.y) + u1*((x-x1)*t1.y)) / ((x2-x)*t2.y + (x-x1)*t1.y);
		ya = (x - x1) * (y2a-y1a) / (x2-x1) + y1a;
//		int ya = Scaler_Next(&ya_int);
		cya = clamp(ya, ytop[x], ybottom[x]); // top
        yb = (x - x1) * (y2b-y1b) / (x2-x1) + y1b;
//        int yb = Scaler_Next(&yb_int);
		cyb = clamp(yb, ytop[x], ybottom[x]); // bottom
		SDL_SetRenderDrawColor(sdl->ren, 55, 35, 35, 255);
		SDL_RenderDrawLine(sdl->ren, x, ytop[x], x, cya-1);

/*		for(int y=ytop[x]; y<=ybottom[x]; ++y)
        {
            if (y >= cya && y <= cyb) {
				y = cyb;
				continue;
			}
            float 	hei;
            float 	mapx, mapz;
			hei = y < cya ? yceil: yfloor;
            CeilingFloorScreenCoordinatesToMapCoordinates(hei, x, y,mapx, mapz);
            unsigned tx = (mapx * 50), txtz = (mapz * 50);
            //printf("%d\n%d\n", txtx, txtz);
            int *floorPix = (int*)sectors->floor_tex->pixels;
            int *surfacePix = (int*)sdl->surf->pixels;
            int pel = floorPix[tx % sectors->floor_tex->w + (txtz % sectors->floor_tex->h) * sectors->floor_tex->w];
            surfacePix[y * W + x] = getpixel(sectors->floor_tex, tx % sectors->floor_tex->w, txtz % sectors->floor_tex->h);
        }
*/
		ytop[x] = cya;
		SDL_SetRenderDrawColor(sdl->ren, 20 * sectors->sector, 20  * (sectors->sector + 1), 12 * (sectors->sector + 1), 255);
		SDL_RenderDrawLine(sdl->ren, x, cyb+1, x, ybottom[x]);

		ybottom[x] = cyb;
		SDL_SetRenderDrawColor(sdl->ren, 255, 200 * (sectors->sector + 1), 0, 255);
		if (wall.type != empty_wall)
		{
			if (t % 2 == 0)
				textLine(x, cya, cyb, (struct Scaler)Scaler_Init(ya,cya,yb, 0, wall.texture->h), txtx, sdl->surf, wall.texture);
	/*		else 
				vline(sdl->surf, x, cya, cyb, 0xff0000, 0x00ff00, 0x000000);*/
			SDL_RenderDrawLine(sdl->ren, x, cya,x, cyb);
		}
		SDL_SetRenderDrawColor(sdl->ren, 0, 0, 0, 255);
		SDL_RenderDrawPoint(sdl->ren, x, cya - 1);
		SDL_RenderDrawPoint(sdl->ren, x, cyb + 1);
	}
	SDL_RenderDrawLine(sdl->ren, end - 1, cya, end - 1, cyb);
	if (wall.type == empty_wall)
	{
		if (wall.sectors[0] && wall.sectors[0]->sector != sectors->sector && wall.sectors[0]->sector != player.curr_sector->sector)
			draw_sectors(wall.sectors[0], player, sdl, ytop, ybottom, begin, end);
		else if (wall.sectors[1] && wall.sectors[1]->sector != sectors->sector && wall.sectors[1]->sector != player.curr_sector->sector)
			draw_sectors(wall.sectors[1], player, sdl, ytop, ybottom, begin, end);
	}
}



void			move_player(t_player *player, float sin_angle, float cos_angle)
{
	int			i;

	i = 0;
	while (i < player->curr_sector->n_walls)
	{
		if(IntersectBox(player->pos.x,player->pos.y, player->pos.x + cos_angle, player->pos.y + sin_angle,
			player->curr_sector->wall[i]->start.x, player->curr_sector->wall[i]->start.y,
			player->curr_sector->wall[i]->end.x, player->curr_sector->wall[i]->end.y)
        && PointSide( player->pos.x + cos_angle, player->pos.y + sin_angle,player->curr_sector->wall[i]->start.x, player->curr_sector->wall[i]->start.y,
			player->curr_sector->wall[i]->end.x, player->curr_sector->wall[i]->end.y) < 0)
        {
			if (player->curr_sector->wall[i]->type == fieled_wall)
				return;
			if (player->curr_sector->wall[i]->sectors[0] &&
				player->curr_sector->sector != player->curr_sector->wall[i]->sectors[0]->sector) 
				player->curr_sector = player->curr_sector->wall[i]->sectors[0];
			else if (player->curr_sector->wall[i]->sectors[1] &&
				player->curr_sector->sector != player->curr_sector->wall[i]->sectors[1]->sector) 
				player->curr_sector = player->curr_sector->wall[i]->sectors[1];
			player->pos = (t_vector){player->pos.x + cos_angle, player->pos.y + sin_angle};
			player->height = EyeHeight + player->curr_sector->floor;
			break;
        }
		i++;
	}
	player->pos = (t_vector){player->pos.x + cos_angle, player->pos.y + sin_angle};
}